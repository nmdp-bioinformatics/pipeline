#!/usr/bin/env perl
=head1 NAME

    ngs-validation-report

=head1 SYNOPSIS

./ngs-validation-report [--experiment] [--validated] [--expected] [--observed] [--blastn] [--email] [--title] [--directory] [--verbose] [--help]
    -x/--experiment       Experiment number (ex. ex014) 
    -l/--validated        Output file from ngs-validate-interp
    -e/--expected         Expected file
    -o/--observed         Observed file
    -n/--blastn           Blast results (observed2blastn.pl)
    -d/--directory        Directory of input files (default = pwd)
    -i/--title            Title of the report (default = report)
    -p/--output           Output directory (default = pwd)
    -m/--email            A list of email addresses seperated by ;
    -t/--test             Run in test mode
    -f/--forced           Force overwrite without prompting
    -v/--verbose          (default = 0)

=head1 AUTHOR     Mike Halagan <mhalagan@nmdp.org>
    
    Associate Bioinformatics Scientist
    3001 Broadway Stree NE
    Minneapolis, MN 55413
    ext. 8225

=head1 DESCRIPTION

    This script takes in the output of ngs-validate-interp and the observed file and generates
    a static HTML website report.

=head1 EXAMPLES
	
    ./ngs-validation-report -t example1 -m example@gmail.com -v 1 
        - Without a input directory 
        - Will default to the current directory

    ./ngs-validation-report -x ex014 -t example1 -m example@gmail.com -v 1
        - Without a input directory but providing an experiment name and a title

    ./ngs-validation-report -d experiments/ -t example1 -m example@gmail.com -v 1
        - With only an input directory
        - This will take in all of the experiments in the provided directory

=head1 CAVEATS
	
    - In order to do the allele code expansion you must
      have LWP::UserAgent installed on your machine. 

    - In order for the email option to work you must be on a linux 
      machine.

=head1 LICENSE

    pipeline  Consensus assembly and allele interpretation pipeline.
    Copyright (c) 2015 National Marrow Donor Program (NMDP)

    This library is free software; you can redistribute it and/or modify it
    under the terms of the GNU Lesser General Public License as published
    by the Free Software Foundation; either version 3 of the License, or (at
    your option) any later version.

    This library is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; with out even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
    License for more details.
 
    You should have received a copy of the GNU Lesser General Public License
    along with this library;  if not, write to the Free Software Foundation,
    Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA.

    > http://www.gnu.org/licenses/lgpl.html

=head1 VERSIONS
	
    Version    Description              Date

    0.1        Initial release          2015-01-14
       - Version that was presented at the NGS meeting
       - Couldn't parse HML
       - Couldn't deal with allele codes 

    0.2       Inital release to mhalagan-nmdp github page            2015-01-30
       - This version could parse HML and dealt with allele codes 

    0.3       updated mhalagan-nmdp github page                      2015-02-11
	   - This version is capable of taking in multiple experiments

	1.0       Version merged with github.com/nmdp-bioinformatics/ngs  2015-02-16 
	   - Fixed minor perl formatting issues
	   - Now uses java HML extracter instead of perl
	   - Added a Makefile.PL and a t/report.t
	   - Moved the README contents to the pipepline README

	1.1        2015-02-16 
	   - Updated the formatting 
	   - Put all main subroutines in html.pm and process.pm

=head1 TODO
	
    - Add match grades
    - Add option to email zip or tar
    - Add option for providing a race config file
    - Add more detailed comments
    - Put all of the HTML subroutines in a separate package (process.pm)
    - Add a test for each individual subroutine (subs.t)
    - Change all of the bootstrap.css to be from http links
    - Change all of the tablesorter links to be from the web
    - Allow multiple different directories to be passed
    - Allow the email option the ability to just email the status

=head1 SUBROUTINES
	
=cut
use strict;
use warnings;
use Data::Dumper;
use Getopt::Long;
use vars qw($USAGE $machine $lwp $start_time $web_template $user $working);
BEGIN{

	$start_time = time;
	$working    = `pwd`;chomp($working);
	$user       = `whoami`;chomp($user);
	$machine    = `uname`;chomp($machine);
	$web_template = $working."/template";

	$lwp = 0; # Check to see if the LWP module is installed
	push(@INC,$working."/lib");
	foreach(@INC){
		my @inc_files = glob "$_/*";
		foreach my $inc_file (@inc_files){
			$lwp = 1 if $inc_file =~ /LWP/;
		}
	}

	$USAGE = 
		qq{./ngs-validation-report [--experiment] [--validated] [--expected] [--observed] [--directory] [--verbose] [--help]
			-x/--experiment       Experiment number (ex. ex014) 
			-l/--validated        Output file from ngs-validate-interp
			-e/--expected         Expected file
			-o/--observed         Observed file
			-i/--title            Title of the report (default = report)
			-u/--population       Population configuration file
			-d/--directory        Directory of input files
			-m/--email            A list of email addresses that the compressed report will be sent to
			-p/--output           Output directory
			-t/--test             Run in test mode (used in t/report.t)
			-f/--forced           Force overwrite without prompting (default = 0)
			-v/--verbose          (default = 0)
		};

}
use html;

if($lwp){ # Only LWP if is installed
	# This allows the script to still run if it isn't installed
	use LWP::UserAgent;
}else{ 
	print STDERR "LWP::UserAgent Not Installed! Proceeding without using allele code conversion API.\n";
}

our $VERSION = 1.1;

my %h_observed_gls;      # Hash that contains the observed haplotypes
my %h_observed;          # Hash that contains the observed Alleles
my %h_expected;          # Hash that contains the expected Alleles
my %h_verified;          # Hash that contains the verified Alleles
my %h_counts;            # Hash that contains the counts
my %h_drbx;              # Hash that contains the drbx issues
my %h_locus_verdict;     # Hash that contains the locus verdict
my %h_subject_pages;     # Hash of the subject pages
my %h_sequence_data;     # Hash of the sequence data
my %h_fails;		     # Hash of the fails
my %h_errors;            # Hash of the errors
my %h_sensitivity;       # Hash of the Sensitivity values
my %h_expected_seqs;     # Hash of the expected sequences
my %h_experiments;       # Hahs of the different experiment numbers
my %h_qc_verified;       # Hash of the qc validated results
my %h_qc_expected;       # Hash of the qc expected results
my %h_qc_zygosity;       # Hash of the qc zygosity results
my %h_qc_verdict;        # Hash of the qc verdict results
my %h_expected_zygosity; # Hash of the expected zygosity results
my %h_sequence_ids;      # Hash of the sequence id results -> blast hmtl pages
my %h_consensus_counts;  # Hash of the consensus sequence counts
my %h_observed_max;      # Hash of the max number of observed sequences 
my %h_error_max;         # Hash of the max number of observed seqs in the failed pages
my %h_drbx_max;          # Hash of the max number of observed seqs in the drbx pages
my %h_qc_max;            # Hash of the max number of observed seqs in the qc pages
my %h_failed_max;        # Hash of the max number of observed seqs in the failed pages 
my %h_qc_counts;         # Hash of the consensus sequence sounts in the qc data
my $s_subject_page = 1;  # Starting number for the subject pages

our ( $s_blast_dir, $s_title, $s_experiment, $s_validated, $s_output, $s_expected, $s_observed, $s_directory, $s_emails, $help, $b_test, $b_forced, $b_verbose) = 
	(undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, 0, 0);

&GetOptions("experiment|x=s" => \$s_experiment, 
			"validated|l=s"  => \$s_validated, 
			"expected|e=s"   => \$s_expected,
			"observed|o=s"   => \$s_observed,
			"title|i=s"      => \$s_title,
			"blastn|n=s"     => \$s_blast_dir,
			"output|p=s"     => \$s_output, 
			"directory|d=s"  => \$s_directory,
			"email|m=s"      => \$s_emails,
			"forced|f=n"     => \$b_forced,
			"test|t=n"       => \$b_test,
			"verbose|v=n"    => \$b_verbose,
			"help|h"         => \$help
			);

if(defined $help){ # If help flag provided then provide the perl doc and exit
	exec('perldoc',$0); 
	die;
}

$s_title     = "report" if(!defined $s_title     || $s_title !~ /\S/);     # If no report title is defined it defaults to report
$s_directory = $working if(!defined $s_directory || $s_directory !~ /\S/); # If input directory isn't provided it equals the working directory
$s_output    = $working if(!defined $s_output    || $s_output    !~ /\S/); # If output directory isn't provided it equals the working directory

# Getting all of the files
if((!defined $s_validated || !defined $s_observed || !defined $s_expected )){
	if(defined $s_experiment){ 
		my $experiment_files = $s_directory."/".$s_experiment."*";
		my @a_ex_files  = glob "$experiment_files";
		my @a_observed  = grep { $_ =~ /observed/ } @a_ex_files;
		my @a_expected  = grep { $_ =~ /expected/ } @a_ex_files;
		my @a_validated  = grep { $_ =~ /validated/ } @a_ex_files;
		$s_observed  = ($#a_observed  == 0 && defined $a_observed[0]) ? $a_observed[0]   : undef;
		$s_expected  = ($#a_expected  == 0 && defined $a_expected[0]) ? $a_expected[0]   : undef;
		$s_validated = ($#a_validated == 0 && defined $a_validated[0]) ? $a_validated[0] : undef;
		$h_experiments{$s_experiment}{VAL} = $s_validated;
		$h_experiments{$s_experiment}{OBS} = $s_observed;
		$h_experiments{$s_experiment}{EXP} = $s_expected;
	}else{
		my @a_files = glob "$s_directory/*";
		my %h_exps = map{ $_ =~ /\/(ex\d+)/; $1 => 1 } grep { $_ =~ /\/(ex\d+)/ } @a_files;
		my @a_experiments = map{ $_ =~ /\/(ex\d+)/; $1 => 1 } grep { $_ =~ /\/(ex\d+)/ } @a_files;
		my $num_experiments = keys %h_experiments;

 		foreach my $s_exp (keys %h_exps){
 			my @a_ex_files  =  glob "$s_directory/$s_exp*";
			my @a_observed  = grep { $_ =~ /observed/ } @a_ex_files;
			my @a_expected  = grep { $_ =~ /expected/ } @a_ex_files;
			my @a_validated = grep { $_ =~ /validated/ } @a_ex_files;
			$s_observed   = (defined $a_observed[0]) ? $a_observed[0] : undef;
			$s_expected   = (defined $a_expected[0]) ? $a_expected[0] : undef;
			$s_validated  = (defined $a_validated[0]) ? $a_validated[0] : undef;

			if(defined $a_validated[1]){ # Getting the QC validated files if present
				my $s_qc_validated = $a_validated[0] =~ /sbt/ ? $a_validated[0] : 
					($a_validated[1] =~ /sbt/ ? $a_validated[1] : undef);
				my $s_ngsp_validated = $a_validated[0] =~ /ngsp/ ? $a_validated[0] : 
					($a_validated[1] =~ /ngsp/ ? $a_validated[1] : undef);
				$h_experiments{$s_exp}{VAL} = $s_ngsp_validated;
				$h_experiments{$s_exp}{QCV} = $s_qc_validated;

			}else{
				$h_experiments{$s_exp}{VAL} = $s_validated;
			}
			if(defined $a_expected[1]){ # Getting the QC expected files if present
				my $s_qc_expected = $a_expected[0] =~ /sbt/ ? $a_expected[0] : 
					($a_expected[1] =~ /sbt/ ? $a_expected[1] : undef);
				my $s_ngsp_expected = $a_expected[0] =~ /ngsp/ ? $a_expected[0] : 
					($a_expected[1] =~ /ngsp/ ? $a_expected[1] : undef);
				$h_experiments{$s_exp}{EXP} = $s_ngsp_expected;
				$h_experiments{$s_exp}{QCE} = $s_qc_expected;
			}else{
				$h_experiments{$s_exp}{EXP} = $s_expected;
			}
			$s_experiment = $a_experiments[0];
			$h_experiments{$s_exp}{OBS} = $s_observed;
 		}
	}
}else{
	# If experiment name isn't provided take it from the files
	if(!defined $s_experiment){
		$s_validated =~ /(ex\d+)/;
		$s_experiment = $1;
	}
	$h_experiments{$s_experiment}{VAL} = $s_validated;
	$h_experiments{$s_experiment}{OBS} = $s_observed;
	$h_experiments{$s_experiment}{EXP} = $s_expected;
}

# Use email option or not
my $b_email = (defined $s_emails && validEmail($s_emails)) ? 1 : 0; 

# Die if the proper files are not provided
die($USAGE,'Please provide a experiment number or valid validated, observed, and expected files') 
	if(!defined $s_experiment && (!defined $s_validated || !defined $s_observed || !defined $s_expected));

# Email option is not available on a mac
die($USAGE,'Email option is NOT AVAILABLE on a mac!') 
	if($b_email && $machine =~ /Darwin/i); 

&initalize(); # Initialize the report directories
#&loadPopulationData() if defined $s_pop_cfg;
my $report_directory = $s_output."/".$s_title;
my $help_index       = $report_directory."/help.html";
my $log_index        = $report_directory."/log.html";
my $experiment_index = $report_directory."/experiment.html";
open(my $log_html, ">","$log_index") or die "CANT OPEN FILE $! $0";
open(my $exp_html, ">","$experiment_index") or die "CANT OPEN FILE $! $0";
open(my $help_html,">","$help_index") or die "CANT OPEN FILE $! $0";

html::logHeader($log_html);
html::helpHtml($help_html);
&printParams(); # Prints out what parameters were used
&loadFiles();   # Load all of the filles
html::experimentsHtml($exp_html,\%h_counts,\%h_experiments);

foreach my $s_exp (keys %h_experiments){

	my $experiment_dir = $report_directory."/".$s_exp;
	my $report_index   = $report_directory."/".$s_exp."/index.html";
	my $results_index  = $report_directory."/".$s_exp."/results.html";
	my $failed_index   = $report_directory."/".$s_exp."/fails.html";
	my $drbx_index     = $report_directory."/".$s_exp."/drbx.html";
	my $errors_index   = $report_directory."/".$s_exp."/errors.html";
	my $qc_index       = $report_directory."/".$s_exp."/qc.html";
	print `mkdir $experiment_dir`;

	my %counts         = %{$h_counts{$s_exp}};           # Counts for the $s_exp experiment
	my %sensitivity    = %{$h_sensitivity{$s_exp}};      # Counts for the $s_exp experiment
	my %loc_verdict    = %{$h_locus_verdict{$s_exp}};    # Counts for the $s_exp experiment
	my %verified       = %{$h_verified{$s_exp}};         # Counts for the $s_exp experiment
	my %observed       = %{$h_observed_gls{$s_exp}};     # Counts for the $s_exp experiment
	my %expected       = %{$h_expected{$s_exp}};         # Counts for the $s_exp experiment
	my %subject        = %{$h_subject_pages{$s_exp}};    # Counts for the $s_exp experiment
	my %seq            = %{$h_sequence_data{$s_exp}};    # Counts for the $s_exp experiment
	my %seqids         = %{$h_sequence_ids{$s_exp}};     # Counts for the $s_exp experiment
	my %consensus      = %{$h_consensus_counts{$s_exp}}; # Counts for the $s_exp experiment
	my $max_results    = $h_observed_max{$s_exp};        # Counts for the $s_exp experiment
	my $max_drbx       = $h_drbx_max{$s_exp};            # Counts for the $s_exp experiment
	my $max_errors     = $h_error_max{$s_exp};           # Counts for the $s_exp experiment
	my $max_failed     = $h_failed_max{$s_exp};          # Counts for the $s_exp experiment
	my $max_qc         = $h_qc_max{$s_exp};              # Counts for the $s_exp experiment

	my %fail;         # Failed results
	my %error;        # Error results
	my %drbx;         # DRBX results
	my %qc_verdict;   # qc verdict results
	my %qc_expected;  # qc expected results

	my ($b_fail, $b_error, $b_drbx, $b_qc)  = (0, 0, 0, 0); # 
	($b_qc,%qc_verdict)  = defined $h_qc_verdict{$s_exp} ? (1,%{$h_qc_verdict{$s_exp}})  : (0,%h_qc_verdict);
	($b_qc,%qc_expected) = defined $h_qc_verdict{$s_exp} ? (1,%{$h_qc_expected{$s_exp}}) : (0,%h_qc_expected);	
	($b_fail,%fail)      = defined $h_fails{$s_exp}  	 ? (1,%{$h_fails{$s_exp}})   	 : (0,%fail);
	($b_error,%error)    = defined $h_errors{$s_exp} 	 ? (1,%{$h_errors{$s_exp}})  	 : (0,%error);
	($b_drbx,%drbx)      = defined $h_drbx{$s_exp}   	 ? (1,%{$h_drbx{$s_exp}})    	 : (0,%drbx);

	# Creating the index.html file
	open(my $index_html,">",$report_index) or die "CANT OPEN FILE $! $0";
	html::indexHeader($index_html, $s_exp, \%h_qc_verdict, $b_drbx, $b_error, $b_fail);
	html::indexBody($index_html, \%counts, \%sensitivity) if !$b_test;
	html::indexFooter($index_html);
	close $index_html;

	# Creating the results.html file
	open(my $results_html,">",$results_index) or die "CANT OPEN FILE $! $0";
	html::htmlHeader($results_html, $s_exp, \%h_qc_verdict, $max_results, "results", $b_drbx, $b_error, $b_fail);
	html::resultsBody($results_html, $s_exp, \%loc_verdict, \%qc_verdict, \%qc_expected, \%verified, \%observed, \%subject, \%error, \%consensus);
	html::htmlFooter($results_html);
	close $results_html;

	# Creating the failed.html file
	if($b_fail){
		open(my $failed_html,">",$failed_index) or die "CANT OPEN FILE $! $0";
		html::htmlHeader($failed_html, $s_exp, \%h_qc_verdict, $max_failed, "failed", $b_drbx, $b_error, $b_fail);
		html::failedBody($failed_html, $s_exp, \%loc_verdict,  \%qc_verdict, \%qc_expected, \%verified, \%observed, \%subject, \%fail, \%consensus);
		html::htmlFooter($failed_html);
		close $failed_html;
	}

	# Creating the drbx.html file
	if($b_drbx){
		open(my $drbx_html,">",$drbx_index) or die "CANT OPEN FILE $! $0";
		html::htmlHeader($drbx_html, $s_exp, \%h_qc_verdict, $max_drbx, "drbx", $b_drbx, $b_error, $b_fail);
		html::drbxBody($drbx_html, $s_exp, \%loc_verdict,  \%qc_verdict, \%qc_expected, \%verified, \%observed, \%subject, \%drbx, \%consensus);
		html::htmlFooter($drbx_html);
		close $drbx_html;
	}

	# Creating the errors.html file
	if($b_error){
		open(my $errors_html,">",$errors_index) or die "CANT OPEN FILE $! $0";
		html::htmlHeader($errors_html, $s_exp, \%h_qc_verdict, $max_errors, "error", $b_drbx, $b_error, $b_fail);
		html::errorsBody($errors_html, $s_exp, \%loc_verdict, \%qc_verdict, \%qc_expected, \%verified, \%observed, \%subject, \%error, \%consensus);
		html::htmlFooter($errors_html);
		close $errors_html;
	}

	# Creating the qc.html file
	if($b_qc){	
		open(my $qc_html,">",$qc_index) or die "CANT OPEN FILE $! $0";
		html::qcHeader($qc_html, $s_exp, $max_qc, $b_drbx, $b_error, $b_fail);
		html::qcBody($qc_html, $s_exp, \%loc_verdict,  \%qc_verdict, \%qc_expected, \%verified, \%observed, \%subject, \%fail);
		html::qcFooter($qc_html);
		close $qc_html;
	}

	my $subject_dir = $s_output."/".$s_title."/".$s_exp."/subjects";
	print `mkdir $subject_dir`;

	# Creating all of the subjects html files
	foreach my $s_ID (keys %{$h_subject_pages{$s_exp}}){
		my $subject_page = $s_output."/".$s_title."/".$s_exp."/subjects/subject".$h_subject_pages{$s_exp}{$s_ID}.".html";
		open(my $subject_html,">",$subject_page) or die "CANT OPEN FILE $! $0";
		html::subjectsHeader($subject_html, $s_exp,  $s_ID, \%h_qc_verdict);
		html::subjectsBody($subject_html, $s_exp, $s_ID, $s_blast_dir, \%loc_verdict, \%qc_verdict, \%qc_expected, \%expected, \%observed, \%seq, \%seqids );
		html::htmlFooter($subject_html);
		close $subject_html;
	}


}

html::logFooter($log_html); # Print out the log HTML file footer
&emailReport($s_emails) if $b_email; # Email out the report if emails are provided
print STDERR "Emailed report to $s_emails\n" if($b_email && $b_verbose);


################################################################################################################
=head2 loadFiles

        Title:    loadFiles
        Usage:    loadFiles($s_experiment, $s_validated, $s_expected, $s_observed);
        Function: This loads all of the data files into the utlized hashes 

=cut
sub loadFiles{

	my %h_no_data;my %h_expected_loci;
	foreach my $s_exp (keys %h_experiments){

		$s_observed  = $h_experiments{$s_exp}{OBS};
		$s_expected  = $h_experiments{$s_exp}{EXP};
		$s_validated = $h_experiments{$s_exp}{VAL};
		my $s_qc_validated = defined $h_experiments{$s_exp}{QCV} ? $h_experiments{$s_exp}{QCV} : undef;
		my $s_qc_expected  = defined $h_experiments{$s_exp}{QCE} ? $h_experiments{$s_exp}{QCE} : undef;

		my $pervious_locus = "";my $n_cnt = 0;
		open(my $obs,"<",$s_observed) or die "CANT OPEN FILE $! $0";
		while(<$obs>){
			chomp;

			if($_ !~ /HLA/){
				my($s_id, $s_seq) = split(/\t/,$_);
				my @a_file  = split(/\//,$s_id); 
				my @a_ID = split(/\./,$a_file[$#a_file]);
				my $ID = $a_ID[0];
				$h_sequence_data{$s_exp}{$ID}{$pervious_locus}{$s_seq}++;
				$h_sequence_ids{$s_exp}{$ID}{$pervious_locus}{$s_seq}   = $ID.".".$pervious_locus.".".$n_cnt++;
				next;
			}

			my($s_id,$s_observe) = split(/\t/,$_);
			my @a_file  = split(/\//,$s_id); 
			my @a_ID = split(/\./,$a_file[$#a_file]);
			my $ID = $a_ID[0];
			my $gl = join("/",map( g2p($_), split(/\//,$s_observe)));
			$gl =~ /HLA-(\D+\d{0,1})\*/;
			my ($s_loc,$b_drbx) = $1 =~ /DRB[3|4|5]/ ? ("DRB1",1) : ($1,0);

			$pervious_locus = $s_loc;
			$h_drbx{$s_exp}{$ID}{$s_loc}++ if $b_drbx;
			
			$gl =~ s/HLA-//g;
			push(@{$h_observed_gls{$s_exp}{$ID}{$s_loc}},$gl);

		}
		close $obs;

		my %h_observed_zygosity;
		foreach my $s_ID (keys %{$h_observed_gls{$s_exp}}){
			$h_subject_pages{$s_exp}{$s_ID} = $s_subject_page++;
			foreach my $s_loc (keys %{$h_observed_gls{$s_exp}{$s_ID}}){
				my $s_glstring;

				my $gl = join("+",@{$h_observed_gls{$s_exp}{$s_ID}{$s_loc}});

				my ($g1,$g2) = split(/\+/,$gl);
				$g1 = !defined $g1 || $g1 !~ /\S/ ? $g2 : $g1;
				$g2 = !defined $g2 || $g2 !~ /\S/ ? $g1 : $g2;

				if($g1 eq $g2){
					$h_observed_zygosity{$s_exp}{$s_ID}{$s_loc} = 1;
				}else{
					$h_observed_zygosity{$s_exp}{$s_ID}{$s_loc} = 2;
				}

				if($#{$h_observed_gls{$s_exp}{$s_ID}{$s_loc}} == 0){
					$s_glstring = expand(join("+",${$h_observed_gls{$s_exp}{$s_ID}{$s_loc}}[0],
							${$h_observed_gls{$s_exp}{$s_ID}{$s_loc}}[0]));
				}else{
					$s_glstring = expand(join("+",@{$h_observed_gls{$s_exp}{$s_ID}{$s_loc}}));
				}

				$s_glstring =~ s/HLA-//g;
				$h_observed{$s_exp}{$s_ID}{$s_loc} = $s_glstring;
			}
		}

		my %h_haplo_total;my %h_haplo_count;
		my %h_allele_total;my %h_allele_count;
		foreach my $s_ID (keys %{$h_observed_gls{$s_exp}}){
			foreach my $s_loc (keys %{$h_observed_gls{$s_exp}{$s_ID}}){
				foreach my $s_gl (@{$h_observed_gls{$s_exp}{$s_ID}{$s_loc}}){
					my %h_alleles   = map{ $_ => 1 } split(/\//,$s_gl);
					my $num_alleles = keys %h_alleles;
					my $sensitivity = 1 / $num_alleles;
					$h_allele_total{$s_loc} += $sensitivity;
					$h_allele_count{$s_loc}++;
				}
				my %h_haplotypes   = map{ $_ => 1 } split(/\|/,$h_observed{$s_exp}{$s_ID}{$s_loc});
				my $num_haplotypes = keys %h_haplotypes;
				my $sensitivity    = 1 / $num_haplotypes;

				$h_haplo_total{$s_loc} += $sensitivity;
				$h_haplo_count{$s_loc}++;
			}
		}

		foreach my $s_loc (keys %h_haplo_count){
			my $average_haplo  = $h_haplo_total{$s_loc}  / $h_haplo_count{$s_loc};
			my $average_allele = $h_allele_total{$s_loc} / $h_allele_count{$s_loc};
			$h_sensitivity{$s_exp}{ALLELE}{$s_loc} = $average_allele;
			$h_sensitivity{$s_exp}{HAPLO}{$s_loc}  = $average_haplo;
		}

		if($s_expected =~ /[hml|xml]$/){
			my $which_extract_expected = `which ngs-extract-expected`;chomp($which_extract_expected);
			if(!defined $which_extract_expected || $which_extract_expected !~ /\S/){
				print STDERR "Parsing HML with perl!\n" if $b_verbose;
				perlParseHML($s_expected, $s_exp, 0);
			}else{
				print STDERR "Parsing HML with ngs-extract-expected\n" if $b_verbose;
				javaParseHML($s_expected, $s_exp, 0);
			}
		}else{
			
			open(my $exp,"<",$s_expected) or die "CANT OPEN FILE $! $0";
			while(<$exp>){
				chomp;
				my($s_file,$s_loc,$s_ars,$s_het,$s_typ1,$s_typ2) = split(/\t/,$_);

				my @a_file  = split(/\//,$s_file);
				my @a_ID = split(/\./,$a_file[$#a_file]);
				my $ID = $a_ID[0];	
				$s_loc =~ s/HLA-//g;$s_typ1 =~ s/HLA-//g;$s_typ2 =~ s/HLA-//g;
				next if !defined $s_loc || $s_loc !~ /\S/;
				next if $s_loc eq "DPB1"; # For now skip DP
				
				$s_typ1 = !defined $s_typ1 || $s_typ1 !~ /\S/ ? $s_typ2 : $s_typ1;
				$s_typ2 = !defined $s_typ2 || $s_typ2 !~ /\S/ ? $s_typ1 : $s_typ2;

				$h_expected{$s_exp}{$ID}{$s_loc} = (isAC($s_typ1) || isAC($s_typ2)) ? (getGL($s_typ1,$s_typ2)) : expand(join("+",sort $s_typ2, $s_typ1));			
				$h_expected_zygosity{$s_exp}{$ID}{$s_loc} = $s_typ1 eq $s_typ2 ? 1 : 2;
				$h_expected_loci{$s_loc}++;
			}
			close $exp;

			if(defined $s_qc_validated && defined $s_qc_expected){
				open(my $qcexp,"<",$s_qc_expected) or die "CANT OPEN FILE $! $0";
				while(<$qcexp>){
					chomp;
					my($s_file,$s_loc,$s_ars,$s_het,$s_typ1,$s_typ2) = split(/\t/,$_);

					my @a_file  = split(/\//,$s_file);
					my @a_ID = split(/\./,$a_file[$#a_file]);
					my $ID = $a_ID[0];	
					$s_loc =~ s/HLA-//g;$s_typ1 =~ s/HLA-//g;$s_typ2 =~ s/HLA-//g;
					next if !defined $s_loc || $s_loc !~ /\S/;
					next if $s_loc eq "DPB1"; # For now skip DP
					
					$s_typ1 = !defined $s_typ1 || $s_typ1 !~ /\S/ ? $s_typ2 : $s_typ1;
					$s_typ2 = !defined $s_typ2 || $s_typ2 !~ /\S/ ? $s_typ1 : $s_typ2;

					$h_qc_expected{$s_exp}{$ID}{$s_loc} = (isAC($s_typ1) || isAC($s_typ2)) ? (getGL($s_typ1,$s_typ2)) : expand(join("+",sort $s_typ2, $s_typ1));			
					$h_qc_zygosity{$s_exp}{$ID}{$s_loc} = $s_typ1 eq $s_typ2 ? 1 : 2;

				}
				close $qcexp;					
			}
		}

		if(defined $s_qc_validated && defined $s_qc_expected){
			if($s_qc_expected =~ /[hml|xml]$/){
				my $which_extract_expected = `which ngs-extract-expected`;chomp($which_extract_expected);
				if(!defined $which_extract_expected || $which_extract_expected !~ /\S/){
					print STDERR "Parsing HML with perl!\n" if $b_verbose;
					perlParseHML($s_qc_expected, $s_exp, 1);
				}else{
					print STDERR "Parsing HML with ngs-extract-expected\n" if $b_verbose;
					javaParseHML($s_qc_expected, $s_exp, 1);
				}
			}else{
				open(my $qcexp,"<",$s_qc_expected) or die "CANT OPEN FILE $! $0";
				while(<$qcexp>){
					chomp;
					my($s_file,$s_loc,$s_ars,$s_het,$s_typ1,$s_typ2) = split(/\t/,$_);

					my @a_file  = split(/\//,$s_file);
					my @a_ID = split(/\./,$a_file[$#a_file]);
					my $ID = $a_ID[0];	
					$s_loc =~ s/HLA-//g;$s_typ1 =~ s/HLA-//g;$s_typ2 =~ s/HLA-//g;
					next if !defined $s_loc || $s_loc !~ /\S/;
					next if $s_loc eq "DPB1"; # For now skip DP
					
					$s_typ1 = !defined $s_typ1 || $s_typ1 !~ /\S/ ? $s_typ2 : $s_typ1;
					$s_typ2 = !defined $s_typ2 || $s_typ2 !~ /\S/ ? $s_typ1 : $s_typ2;

					$h_qc_expected{$s_exp}{$ID}{$s_loc} = (isAC($s_typ1) || isAC($s_typ2)) ? (getGL($s_typ1,$s_typ2)) : expand(join("+",sort $s_typ2, $s_typ1));			
					$h_qc_zygosity{$s_exp}{$ID}{$s_loc} = $s_typ1 eq $s_typ2 ? 1 : 2;

				}
				close $qcexp;
			}

		}

		open(my $ver,"<",$s_validated) or die "CANT OPEN FILE $! $0";
		while(<$ver>){
			chomp;
			my($s_status, $s_file, $s_typing) = split(/\t/,$_);
			my @a_file  = split(/\//,$s_file); 
			my @a_ID    = split(/\./,$a_file[$#a_file]);
			my $ID = $a_ID[0];
			$s_typing =~ /^HLA-(\D+\d{0,1})\*/;
			my $s_loc = $1;
			$s_typing =~ s/HLA-//;
			next if !defined $s_loc || $s_loc !~ /\S/;
			next if $s_loc eq "DPB1"; # For now skip DP
			
			my $gl = defined $h_observed_gls{$s_exp}{$ID}{$s_loc} ? join("+",@{$h_observed_gls{$s_exp}{$ID}{$s_loc}}) : "+";
			my ($g1,$g2) = split(/\+/,$gl);
			$g1 = !defined $g1 || $g1 !~ /\S/ ? $g2 : $g1;
			$g2 = !defined $g2 || $g2 !~ /\S/ ? $g1 : $g2;

			if($s_status eq "FAIL" && ($g1 =~ /DRB[3|4|5]/ || $g2 =~ /DRB[3|4|5]/)){
				$h_verified{$s_exp}{$ID}{$s_loc}{$s_typing} = "DRBX";
			}else{
				$h_verified{$s_exp}{$ID}{$s_loc}{$s_typing} = $s_status;
			}

		}
		close $ver;

		if(defined $s_qc_validated && defined $s_qc_expected){
			open(my $qc_ver,"<",$s_qc_validated) or die "CANT OPEN FILE $! $0";
			while(<$qc_ver>){
				chomp;
				my($s_status, $s_file, $s_typing) = split(/\t/,$_);
				my @a_file  = split(/\//,$s_file); 
				my @a_ID    = split(/\./,$a_file[$#a_file]);
				my $ID = $a_ID[0];
				$s_typing =~ /^HLA-(\D+\d{0,1})\*/;
				my $s_loc = $1;
				$s_typing =~ s/HLA-//;
				next if !defined $s_loc || $s_loc !~ /\S/;
				next if $s_loc eq "DPB1"; # For now skip DP

				my $gl = defined $h_observed_gls{$s_exp}{$ID}{$s_loc} ? join("+",@{$h_observed_gls{$s_exp}{$ID}{$s_loc}}) : "+";
				my ($g1,$g2) = split(/\+/,$gl);
				$g1 = !defined $g1 || $g1 !~ /\S/ ? $g2 : $g1;
				$g2 = !defined $g2 || $g2 !~ /\S/ ? $g1 : $g2;

				if($s_status eq "FAIL" && ($g1 =~ /DRB[3|4|5]/ || $g2 =~ /DRB[3|4|5]/)){
					$h_qc_verified{$s_exp}{$ID}{$s_loc}{$s_typing} = "DRBX";
				}else{
					$h_qc_verified{$s_exp}{$ID}{$s_loc}{$s_typing} = $s_status;
				}

			}
			close $qc_ver;
		}

		foreach my $s_ID (keys %{$h_qc_verified{$s_exp}}){
			my $loc_cnt = 0;my $n_error = 0;
			foreach my $s_loc (keys %{$h_qc_verified{$s_exp}{$s_ID}}){
				my $n_typings = 0;my $n_drbx = 0;my $n_qc_typings = 0;
				foreach my $s_typing (keys %{$h_qc_verified{$s_exp}{$s_ID}{$s_loc}}){
					
					if($h_qc_verified{$s_exp}{$s_ID}{$s_loc}{$s_typing} eq "DRBX"){
						$n_drbx++;
					}
					if($h_qc_verified{$s_exp}{$s_ID}{$s_loc}{$s_typing} eq "PASS"){
						$n_typings++;
					}
				}

				if(!defined $h_observed_gls{$s_exp}{$s_ID}{$s_loc}[0]){
					#Need to flag this as no calls
					$h_qc_verdict{$s_exp}{$s_ID}{$s_loc} = "ERROR" if defined $h_qc_verified{$s_exp}{$s_ID}{$s_loc};	
					$h_qc_counts{$s_exp}{LOCUS}{$s_loc}{ERROR}++; 
					$h_qc_counts{$s_exp}{LOCUS}{TOTAL}{ERROR}++;
					next;
				}
				
				my $gl = join("+",@{$h_observed_gls{$s_exp}{$s_ID}{$s_loc}});
				my ($g1,$g2) = split(/\+/,$gl);
				$g1 = !defined $g1 || $g1 !~ /\S/ ? $g2 : $g1;
				$g2 = !defined $g2 || $g2 !~ /\S/ ? $g1 : $g2;	
				$g1 =~ /^(\D+\d{0,1})\*/;my $s_locus1 = $1;		
				$g2 =~ /^(\D+\d{0,1})\*/;my $s_locus2 = $1;	

				my $num_typings = keys %{$h_qc_verified{$s_exp}{$s_ID}{$s_loc}};

				if($n_typings == $num_typings){
					$h_qc_verdict{$s_exp}{$s_ID}{$s_loc} = "PASS";
					$h_qc_counts{$s_exp}{LOCUS}{$s_loc}{ERROR}++; 
					$h_qc_counts{$s_exp}{LOCUS}{TOTAL}{ERROR}++;				
				}elsif($s_loc eq "DRB1" && $n_drbx != 0){
					$h_qc_verdict{$s_exp}{$s_ID}{$s_loc} = "DRBX";
					$h_qc_counts{$s_exp}{LOCUS}{$s_loc}{DRBX}++; 
					$h_qc_counts{$s_exp}{LOCUS}{DRBX}{DRBX}++;	
				}elsif(!defined $h_qc_zygosity{$s_exp}{$s_ID}{$s_loc} || !defined $h_observed_zygosity{$s_exp}{$s_ID}{$s_loc} 
					 || $h_qc_zygosity{$s_exp}{$s_ID}{$s_loc} != $h_observed_zygosity{$s_exp}{$s_ID}{$s_loc}){
					$h_qc_verdict{$s_exp}{$s_ID}{$s_loc} = "ERROR";	
					$h_qc_counts{$s_exp}{LOCUS}{$s_loc}{ERROR}++; 
					$h_qc_counts{$s_exp}{LOCUS}{TOTAL}{ERROR}++;		
				}else{
					$h_qc_verdict{$s_exp}{$s_ID}{$s_loc} = "FAIL";
					$h_qc_counts{$s_exp}{LOCUS}{$s_loc}{FAIL}++; 
					$h_qc_counts{$s_exp}{LOCUS}{TOTAL}{FAIL}++;	
				}

			}

			foreach my $s_loc (keys %{$h_qc_verified{$s_exp}{$s_ID}}){
				foreach my $s_typing (keys %{$h_qc_verified{$s_exp}{$s_ID}{$s_loc}}){
					if($h_qc_verified{$s_exp}{$s_ID}{$s_loc}{$s_typing} eq "PASS"){
						$h_qc_counts{$s_exp}{ALLELE}{$s_loc}{PASS}++;
						$h_qc_counts{$s_exp}{ALLELE}{TOTAL}{PASS}++; 
					}elsif($h_qc_verified{$s_exp}{$s_ID}{$s_loc} eq "ERROR"){
						$h_qc_counts{$s_exp}{ALLELE}{$s_loc}{ERROR}++;
						$h_qc_counts{$s_exp}{ALLELE}{TOTAL}{ERROR}++;
					}elsif($h_qc_verified{$s_exp}{$s_ID}{$s_loc} eq "DRBX"){
						$h_qc_counts{$s_exp}{ALLELE}{$s_loc}{DRBX}++;
						$h_qc_counts{$s_exp}{ALLELE}{TOTAL}{DRBX}++;
					}else{
						$h_qc_counts{$s_exp}{ALLELE}{$s_loc}{FAIL}++;
						$h_qc_counts{$s_exp}{ALLELE}{TOTAL}{FAIL}++;
					}
				}
			}
		}

		
		foreach my $s_ID (keys %{$h_verified{$s_exp}}){
			my $loc_cnt = 0;my $n_error = 0;my $n_drbx = 0;my $n_fail = 0;
			foreach my $s_loc (keys %{$h_verified{$s_exp}{$s_ID}}){
				my $n_typings = 0;my $n_qc_typings = 0;
				foreach my $s_typing (keys %{$h_verified{$s_exp}{$s_ID}{$s_loc}}){
					if($h_verified{$s_exp}{$s_ID}{$s_loc}{$s_typing} eq "DRBX"){
						$n_drbx++;
					}
					if($h_verified{$s_exp}{$s_ID}{$s_loc}{$s_typing} eq "PASS"){
						$n_typings++;
					}
				}

				if(!defined $h_observed_gls{$s_exp}{$s_ID}{$s_loc}[0]){
					foreach($s_exp,$s_ID,$s_loc){ chomp($_);}
					print STDERR "No Call: ",join("\t",$s_exp,$s_ID,$s_loc),"\n" if $b_verbose;
					
					if(defined $h_subject_pages{$s_exp}{$s_ID}){
						my $id_link = $s_exp."/subjects/subject".$h_subject_pages{$s_exp}{$s_ID}.".html";
						print $log_html  "No data found for $s_exp <a href=\"$id_link\" class=\"id_links\">$s_ID</a> at $s_loc!!<br>\n";
					}else{
						print $log_html  "No data found for $s_exp $s_ID at $s_loc!! **<br>\n";
						$h_no_data{$s_exp}{$s_ID}++;
					}

					$h_counts{$s_exp}{LOCUS}{$s_loc}{ERROR}++; 
					$h_counts{$s_exp}{LOCUS}{TOTAL}{ERROR}++;
					$h_locus_verdict{$s_exp}{$s_ID}{$s_loc} = "ERROR";
					$h_errors{$s_exp}{$s_ID}{$s_loc}++;
					$n_error++;
					#Need to flag this as no calls
					next;
				}
				
				my $gl = join("+",@{$h_observed_gls{$s_exp}{$s_ID}{$s_loc}});
				my ($g1,$g2) = split(/\+/,$gl);
				$g1 = !defined $g1 || $g1 !~ /\S/ ? $g2 : $g1;
				$g2 = !defined $g2 || $g2 !~ /\S/ ? $g1 : $g2;

				$g1 =~ /^(\D+\d{0,1})\*/;my $s_locus1 = $1;		
				$g2 =~ /^(\D+\d{0,1})\*/;my $s_locus2 = $1;	

				my $num_typings = keys %{$h_verified{$s_exp}{$s_ID}{$s_loc}};

				if($n_typings == $num_typings){
					$h_counts{$s_exp}{LOCUS}{$s_loc}{PASS}++;
					$h_counts{$s_exp}{LOCUS}{TOTAL}{PASS}++;
					$h_locus_verdict{$s_exp}{$s_ID}{$s_loc} = "PASS";
					$loc_cnt++;

				}elsif($s_loc eq "DRB1" && $n_drbx != 0){
					$h_counts{$s_exp}{LOCUS}{$s_loc}{DRBX}++;
					$h_counts{$s_exp}{LOCUS}{TOTAL}{DRBX}++;
					$h_locus_verdict{$s_exp}{$s_ID}{$s_loc} = "DRBX";
					$h_drbx{$s_exp}{$s_ID}{$s_loc}++;

				}elsif(!defined $h_expected_zygosity{$s_exp}{$s_ID}{$s_loc} || !defined $h_observed_zygosity{$s_exp}{$s_ID}{$s_loc} 
					|| $h_expected_zygosity{$s_exp}{$s_ID}{$s_loc} != $h_observed_zygosity{$s_exp}{$s_ID}{$s_loc}){

					$h_counts{$s_exp}{LOCUS}{$s_loc}{ERROR}++;
					$h_counts{$s_exp}{LOCUS}{TOTAL}{ERROR}++;
					$h_locus_verdict{$s_exp}{$s_ID}{$s_loc} = "ERROR";
					$h_errors{$s_exp}{$s_ID}{$s_loc}++;
					$n_error++;
				}else{		
					$h_counts{$s_exp}{LOCUS}{$s_loc}{FAIL}++;
					$h_counts{$s_exp}{LOCUS}{TOTAL}{FAIL}++;
					$h_locus_verdict{$s_exp}{$s_ID}{$s_loc} = "FAIL";
					$h_fails{$s_exp}{$s_ID}{$s_loc}++;
					$n_fail++;		
				}

			}

			my $num_typs = (keys %{$h_verified{$s_exp}{$s_ID}});
			foreach my $s_loc (keys %{$h_verified{$s_exp}{$s_ID}}){
				foreach my $s_typing (keys %{$h_verified{$s_exp}{$s_ID}{$s_loc}}){
					if($h_verified{$s_exp}{$s_ID}{$s_loc}{$s_typing} eq "PASS"){
						$h_counts{$s_exp}{ALLELE}{$s_loc}{PASS}++;
						$h_counts{$s_exp}{ALLELE}{TOTAL}{PASS}++; 
					}elsif($h_locus_verdict{$s_exp}{$s_ID}{$s_loc} eq "ERROR"){
						$h_counts{$s_exp}{ALLELE}{$s_loc}{ERROR}++;
						$h_counts{$s_exp}{ALLELE}{TOTAL}{ERROR}++;
					}elsif($h_locus_verdict{$s_exp}{$s_ID}{$s_loc} eq "DRBX"){
						$h_counts{$s_exp}{ALLELE}{$s_loc}{DRBX}++;
						$h_counts{$s_exp}{ALLELE}{TOTAL}{DRBX}++;
					}else{
						$h_counts{$s_exp}{ALLELE}{$s_loc}{FAIL}++;
						$h_counts{$s_exp}{ALLELE}{TOTAL}{FAIL}++;
					}
				}
			}

			if($loc_cnt == $num_typs && $n_error == 0){
				$h_counts{$s_exp}{SUBJECT}{TOTAL}{PASS}++;
			}elsif($loc_cnt != 5 && $n_error == 0 && $n_drbx == 0 && $n_fail != 0){
				$h_counts{$s_exp}{SUBJECT}{TOTAL}{FAIL}++;
			}elsif($loc_cnt != 5 && $n_error != 0){
				$h_counts{$s_exp}{SUBJECT}{TOTAL}{ERROR}++;
			}elsif($loc_cnt != 5 && $n_drbx > 0){
				$h_counts{$s_exp}{SUBJECT}{TOTAL}{DRBX}++;
			}else{
				$h_counts{$s_exp}{SUBJECT}{TOTAL}{ERROR}++;				
			}

		}

		my @a_loci = split(/,/,"A,B,C,DRB1,DQB1");
		foreach my $s_l (@a_loci){

			$h_counts{$s_exp}{LOCUS}{$s_l}{PASS}     = 0 if(!defined $h_counts{$s_exp}{LOCUS}{$s_l}{PASS});
			$h_counts{$s_exp}{LOCUS}{$s_l}{FAIL}     = 0 if(!defined $h_counts{$s_exp}{LOCUS}{$s_l}{FAIL});
			$h_counts{$s_exp}{LOCUS}{$s_l}{ERROR}    = 0 if(!defined $h_counts{$s_exp}{LOCUS}{$s_l}{ERROR});
			$h_counts{$s_exp}{LOCUS}{$s_l}{DRBX}     = 0 if(!defined $h_counts{$s_exp}{LOCUS}{$s_l}{DRBX});

			$h_counts{$s_exp}{ALLELE}{$s_l}{PASS}    = 0 if(!defined $h_counts{$s_exp}{ALLELE}{$s_l}{PASS});
			$h_counts{$s_exp}{ALLELE}{$s_l}{FAIL}    = 0 if(!defined $h_counts{$s_exp}{ALLELE}{$s_l}{FAIL});
			$h_counts{$s_exp}{ALLELE}{$s_l}{ERROR}   = 0 if(!defined $h_counts{$s_exp}{ALLELE}{$s_l}{ERROR});	
			$h_counts{$s_exp}{ALLELE}{$s_l}{DRBX}    = 0 if(!defined $h_counts{$s_exp}{ALLELE}{$s_l}{DRBX});

			$h_counts{$s_exp}{SUBJECT}{TOTAL}{PASS}  = 0 if(!defined $h_counts{$s_exp}{SUBJECT}{TOTAL}{PASS});
			$h_counts{$s_exp}{SUBJECT}{TOTAL}{ERROR} = 0 if(!defined $h_counts{$s_exp}{SUBJECT}{TOTAL}{ERROR});
			$h_counts{$s_exp}{SUBJECT}{TOTAL}{FAIL}  = 0 if(!defined $h_counts{$s_exp}{SUBJECT}{TOTAL}{FAIL});
			$h_counts{$s_exp}{SUBJECT}{TOTAL}{DRBX}  = 0 if(!defined $h_counts{$s_exp}{SUBJECT}{TOTAL}{DRBX});

		}

		if($b_verbose){
			print STDERR "$s_exp files loaded\n";
			print $log_html "$s_exp files loaded<br>";
			print STDERR "Observed File:  $s_observed\n";
			print $log_html "Observed File:  $s_observed<br>";
			print STDERR "Expected File:  $s_expected\n";
			print $log_html "Expected File:  $s_expected<br>";
			print STDERR "Validated File: $s_validated\n";
			print $log_html "Validated File: $s_validated<br><br>";
		}

		#Determining the max number of columns for each page
		my $n_max_error = 0;
		if(defined $h_errors{$s_exp}){
			foreach my $s_ID (keys %{$h_errors{$s_exp}}){
				foreach my $s_loc (keys %{$h_errors{$s_exp}{$s_ID}}){
					$n_max_error = ($#{$h_observed_gls{$s_exp}{$s_ID}{$s_loc}} + 1) > $n_max_error ?
						 ($#{$h_observed_gls{$s_exp}{$s_ID}{$s_loc}} + 1) : $n_max_error;
				}
			}
		}
		$h_error_max{$s_exp} = $n_max_error;

		my $n_max_drbx = 0;
		if(defined $h_drbx{$s_exp}){
			foreach my $s_ID (keys %{$h_drbx{$s_exp}}){
				foreach my $s_loc (keys %{$h_drbx{$s_exp}{$s_ID}}){
					$n_max_drbx = ($#{$h_observed_gls{$s_exp}{$s_ID}{$s_loc}} + 1) > $n_max_drbx ?
						 ($#{$h_observed_gls{$s_exp}{$s_ID}{$s_loc}} + 1) : $n_max_drbx;
				}
			}
		}
		$h_drbx_max{$s_exp} = $n_max_drbx;

		my $n_max_failed = 0;
		if(defined $h_fails{$s_exp}){
			foreach my $s_ID (keys %{$h_fails{$s_exp}}){
				foreach my $s_loc (keys %{$h_fails{$s_exp}{$s_ID}}){
					$n_max_failed = ($#{$h_observed_gls{$s_exp}{$s_ID}{$s_loc}} + 1) > $n_max_failed ?
						 ($#{$h_observed_gls{$s_exp}{$s_ID}{$s_loc}} + 1) : $n_max_failed;
				}
			}				
		}
		$h_failed_max{$s_exp} = $n_max_failed;

		my $n_max_qc = 0;
		if(defined $h_qc_verdict{$s_exp}){
			foreach my $s_ID (keys %{$h_qc_verdict{$s_exp}}){
				foreach my $s_loc (keys %{$h_qc_verdict{$s_exp}{$s_ID}}){
					$n_max_qc = ($#{$h_observed_gls{$s_exp}{$s_ID}{$s_loc}} + 1) > $n_max_qc ?
						 ($#{$h_observed_gls{$s_exp}{$s_ID}{$s_loc}} + 1) : $n_max_qc;
				}
			}
		}
		$h_qc_max{$s_exp} = $n_max_qc;			
			
		my $n_max = 0;
		foreach my $s_ID (keys %{$h_observed_gls{$s_exp}}){
			foreach my $s_loc (keys %{$h_observed_gls{$s_exp}{$s_ID}}){
				$n_max = ($#{$h_observed_gls{$s_exp}{$s_ID}{$s_loc}} + 1) > $n_max ? 
					($#{$h_observed_gls{$s_exp}{$s_ID}{$s_loc}} + 1) : $n_max;			
				if(defined $h_consensus_counts{$s_exp}{$s_ID}{$s_loc}){
					if( $h_consensus_counts{$s_exp}{$s_ID}{$s_loc} < ($#{$h_observed_gls{$s_exp}{$s_ID}{$s_loc}} + 1)){
						$h_consensus_counts{$s_exp}{$s_ID}{$s_loc} = ($#{$h_observed_gls{$s_exp}{$s_ID}{$s_loc}} + 1);
					}
				}else{
					$h_consensus_counts{$s_exp}{$s_ID}{$s_loc} = ($#{$h_observed_gls{$s_exp}{$s_ID}{$s_loc}} + 1);
				}
			}
		}
		print STDERR "Max number of observed consensus sequences: $s_exp\t$n_max\n\n"	if $b_verbose;	
		$h_observed_max{$s_exp} = $n_max;

	}


	if($b_verbose){
		print $log_html "** Missing observed data at all loci!<br>";
		foreach my $s_exp (keys %h_no_data){
			foreach my $s_ID (keys %{$h_no_data{$s_exp}}){
				print STDERR "No data at all loci for $s_ID in $s_exp\n";
				print $log_html "No data at all loci for $s_ID in $s_exp<br>";
			}
		}
	}


}
################################################################################################################
=head2 loadPopulationData

        Title:    loadPopulationData
        Usage:    loadPopulationData();
        Function: This loads all of data that links an id to a population

=cut
sub loadPopulationData{


}
################################################################################################################
=head2 validEmail

	Title:     validEmail
	Usage:     validEmail($s_emails)
	Function:  
	Returns:   na
	Args:      email list

=cut
sub validEmail{

	my $s_emails_list = shift;
	return 0 if !defined $s_emails_list;

	my @a_emails      = split(/;/,$s_emails_list);
	my $valid_emails = 1;
	foreach my $s_email (@a_emails){
		$valid_emails = 0 if($s_email !~ /\.com/ || $s_email !~ /\@/);
	}

	return $valid_emails;

}
################################################################################################################
=head2 isAC

	Title:     isAC
	Usage:     isAC($allele_code)
	Function:  determines if an allele is an allele code or not
	Returns:   1 if ac 0 if not
	Args:      allele code

=cut
sub isAC{
	my $s_a = shift;
	return 1 if $s_a =~ /\*\d{2,3}:\D{2,5}/;
	return 0;
}
################################################################################################################
=head2 getGL

	Title:     getGL
	Usage:     getGL($loc,$typing)
	Function:  
	Returns:   allele list
	Args:      allele code

=cut
sub getGL{

	my($typ1,$typ2) = @_;
	$typ1 =~ /(\D+\d{0,1})\*/;
	my $s_gl1 = isAC($typ1) ? ac2gl($1,$typ1) : $typ1;
	my $s_gl2 = isAC($typ2) ? ac2gl($1,$typ2) : $typ2;
	return (expand(join("+",sort($s_gl1,$s_gl2))));

}
################################################################################################################
=head2 ac2gl

	Title:     ac2gl
	Usage:     ac2gl($loc,$typing)
	Function:  
	Returns:   allele list
	Args:      allele code

=cut
sub ac2gl{

	my($loc,$typ) = @_;
	$typ =~ s/$loc\*//;

	my $ua = new LWP::UserAgent;
    $ua->agent("AlleleCodeClient/0.1");
    my @allele_list_list;my @ret;

    my $url = "http://emmes-dev.nmdp.org:8080/ac/api/decode?typing=$loc*$typ";
    my $response = $ua->request(new HTTP::Request("GET", $url));
    my $code = $response->code;
    my $content = $response->content;
    my $headers = $response->headers_as_string;
    if ($code == 200) {  # OK
        #print STDERR "Request url:  $url\nStatus $code Content: \n$content\n"; 
        my @allele_list_list = split ("/", $content);
        push @ret, @allele_list_list;
    } elsif ($code == 400) { # Bad Request
        # Request syntax was bad, or the typing was bad
        # print error and keep original typing.
        print STDERR "Bad request: $content\n\turl:  $url\n";
        print $log_html "NMDP Email addresses DO NOT WORK!<br>";
        push @ret, ("$loc*$typ");
    } else {
        die "System error: code=$code $content\n";
    }

    return join("/",@ret);

}
################################################################################################################
=head2 emailReport

	Title:     emailReport
	Usage:     emailReport($s_emails)
	Function:  compresses and emails the report to the list of given emails
	Returns:   na
	Args:      email list

=cut
sub emailReport{

	my $s_emails_list = shift;
	my @a_emails      = split(/;/,$s_emails_list);
	$report_directory = "report/";
	print `tar cvzf report.tar.gz $report_directory`; 
	print `echo "Report" | mailx -a report.tar.gz -s Report $s_emails_list`;

}
################################################################################################################
=head2 g2p

	Title:     g2p
	Usage:     my $s_allele = g2p($s_genomic_allele)
	Function:  This turns genomic level alleles into protein level alleles 
			   This will r
	Returns:   protein level alleles
	Args:      genomic level allele

=cut
sub g2p{
	my $allele    = shift;
	return $allele if $allele !~ /:/;
	my @a_alleles = split(/:/,$allele);
	return join(":",$a_alleles[0],$a_alleles[1]);
}
################################################################################################################
=head2 expand

	Title: expand
	Usage:
	Function:
	Returns:
	Args:

=cut
sub expand{

	my $gl = shift;
	my ($s_gl1,$s_gl2) = split(/\+/,$gl);

	if(!defined $s_gl1 || !defined $s_gl2){
		print STDERR "$gl\n";
		print $log_html "Error GL: $gl<br>";
		exit;
	}
	my %h_gl;
	foreach my $s_allele (split(/\//,$s_gl1)){
		foreach my $s_allele2 (split(/\//,$s_gl2)){
			$h_gl{join("+",sort($s_allele,$s_allele2))}++;
		}
	}
	return join("|",sort keys %h_gl);

}
################################################################################################################
=head2 printParams

	Title: printParams
	Usage:
	Function:
	Returns:
	Args:

=cut
sub printParams{

	my  $params = "<b>./ngs-validation-report ";
	$params = $params." -x $s_experiment "if(defined $s_experiment);
	$params = $params." -t $s_title "     if(defined $s_title);	
	$params = $params." -v $s_validated " if(defined $s_validated);
	$params = $params." -e $s_expected "  if(defined $s_expected);
	$params = $params." -o $s_observed "  if(defined $s_observed);		
	$params = $params." -p $s_output "    if(defined $s_output);	
	$params = $params." -d $s_directory " if(defined $s_directory);
	$params = $params." -m $s_emails "    if(defined $s_emails);
	$params = $params." -f $b_forced "    if($b_forced);
	$params = $params." -v $b_verbose "   if($b_verbose);
	print $log_html $params."</b><br><br>";

}
################################################################################################################
=head2 perlParseHML

	Title: perlParseHML
	Usage:
	Function:
	Returns:
	Args:

=cut
sub perlParseHML{

	my ($hml_file, $s_exp, $b_qc) = @_;

	# Initial HML variables
	my $sample_id; 
	my $center_cde;    
	my $locus;    
	my $assembly;  
	my $contig;   
	my $start;         
	my $end;      
	my $id;
	my $strand;    
	my $phasing_group;
	my $sequence; 
	my $interp_date;
	my $allele_db; 
	my $db_version;    
	my $glstring;
	my $b_seq = 0; 
	my $b_glstring = 0;

	open(my $hml,"<",$hml_file) or die "CANT OPEN FILE $! $0";
	while(<$hml>){
		chomp;
		
		if($b_seq){ # If the previous line was a sequence header then..
			$_ =~ s/\s+//g;
			$sequence = $_;
			my $assembly_info = join(";",$id,$assembly,$contig,$start,$end,$strand);
			$h_expected_seqs{$sample_id}{$assembly_info}{$phasing_group}{$sequence}++;
			$b_seq = 0;
			next;
		}
		if($b_glstring){ # If the previous line was a glstring header then..
			$_ =~ s/\s+//g;
			$glstring   = $_;
			$b_glstring = 0;my %h_gls;
			my $interp_info = join(";",$interp_date,$allele_db,$db_version);
			
			
			my @a_haps = split(/\|/,$glstring);
			foreach my $s_hap (@a_haps){
				my($s_g1,$s_g2) = split(/\+/,$s_hap);
				if(!$b_qc){
					$h_expected_zygosity{$s_exp}{$sample_id}{$locus} = $s_g1 eq $s_g2 ? 1 : 2;
				}else{
					$h_qc_zygosity{$s_exp}{$sample_id}{$locus} = $s_g1 eq $s_g2 ? 1 : 2;
				}
				my $gls = (isAC($s_g1) || isAC($s_g2)) ? (getGL($s_g1,$s_g2)) : join("+",sort $s_g2, $s_g1);
				foreach(split(/\|/,$gls)){ $h_gls{$_}++; }
			}
			$glstring = join("|",sort keys %h_gls);
			if(!$b_qc){
				$h_expected{$s_exp}{$sample_id}{$locus}    = $glstring;
			}else{
				$h_qc_expected{$s_exp}{$sample_id}{$locus} = $glstring;
			}
			#$h_interp{$sample_id}{$locus}  = $interp_info;
			next;
		}
		if($_ =~ /<sample id=\"(.+)\" center-code=\"(\d+)\">/){
			$sample_id = $1;$center_cde = $2;
		}
		if($_ =~ /<sbt-ngs locus="(.+)" test-id=".+" test-id-source=".+">/){
			$locus = $1;
		}
		if($_ =~ /<region assembly="(.+)" contig="(.+)" start="(.+)" end="(.+)" id="(.+)" strand="(.+)" \/>/){
			$assembly = $1;$contig = $2;$start = $3;$end = $4;$id = $5;$strand=$6;
		}
		if($_ =~ /<sequence alphabet=".+" phasing-group="(\d+)">/){
			$phasing_group = $1;
			$b_seq = 1;
		}
		if($_ =~ /<interpretation date="(.+)" allele-db="(.+)" allele-version="(.+)">/){
			$interp_date = $1; $allele_db = $2;$db_version = $3;
		}
		if($_ =~ /<glstring>/){
			$b_glstring = 1;
		}
		
	}
	close $hml;


}
################################################################################################################
=head2 perlParseHML

	Title: perlParseHML
	Usage:
	Function:
	Returns:
	Args:

=cut
sub javaParseHML{

	my ($hml_file, $s_exp, $b_qc) = @_;

	foreach(`ngs-extract-expected -i $hml_file -g`){
		chomp($_);
		my($s_file,$s_loc,$s_ars,$s_het,$s_typ1,$s_typ2) = split(/\t/,$_);

		next if !defined $s_typ1 && !defined $s_typ2;
		my $ID;
		if($s_file =~ /\//){
			my @a_file  = split(/\//,$s_file);
			my @a_ID = split(/\./,$a_file[$#a_file]);
			$ID = $a_ID[0];	
		}else{
			my @a_ID = split(/\./,$s_file);
			$ID = $a_ID[0];	
		}
		
		$s_loc =~ s/HLA-//g;$s_typ1 =~ s/HLA-//g;$s_typ2 =~ s/HLA-//g;
		next if !defined $s_loc || $s_loc !~ /\S/;
		next if $s_loc eq "DPB1"; # For now skip DP
		
		$s_typ1 = !defined $s_typ1 || $s_typ1 !~ /\S/ ? $s_typ2 : $s_typ1;
		$s_typ2 = !defined $s_typ2 || $s_typ2 !~ /\S/ ? $s_typ1 : $s_typ2;

		if(!$b_qc){
			$h_expected{$s_exp}{$ID}{$s_loc} = (isAC($s_typ1) || isAC($s_typ2)) ? (getGL($s_typ1,$s_typ2)) : expand(join("+",sort $s_typ2, $s_typ1));			
			$h_expected_zygosity{$s_exp}{$ID}{$s_loc} = $s_typ1 eq $s_typ2 ? 1 : 2;
		}else{
			$h_qc_expected{$s_exp}{$ID}{$s_loc} = (isAC($s_typ1) || isAC($s_typ2)) ? (getGL($s_typ1,$s_typ2)) : expand(join("+",sort $s_typ2, $s_typ1));			
			$h_qc_zygosity{$s_exp}{$ID}{$s_loc} = $s_typ1 eq $s_typ2 ? 1 : 2;
		}
	}


}
################################################################################################################
=head2 initalize

	Title:    initalize
	Usage:    initalize( $directory, $web_template, $verbose )
	Function:
	Returns:
	Args:

=cut
sub initalize{

	my $report_dir = $s_output."/".$s_title;
	if( -d $report_dir && !$b_forced){
		print STDERR "Exiting because report directory already exists\n";
		exit;
	}else{
		if($b_forced && -d $report_dir){
			print STDERR "Deleting old reporting directory!\n" if $b_verbose;
			print `rm -R $report_dir`;
		}
		print STDERR "Populating report directory with web files\n" if $b_verbose;
		print `mkdir $report_dir`;
		foreach("css","js","img"){
			my $web_dir = $report_dir."/".$_;
			print STDERR $web_dir,"\n" if $b_verbose;
			print `mkdir $web_dir`;
			my $template = $web_template."/".$_;
			if(-d $template){
				my $temp_copy = $template."/*";
				print `cp $temp_copy $web_dir`;
			}
		}
		if(defined $s_blast_dir && -d $s_blast_dir){
			print STDERR "copying blast files\n" if $b_verbose;
			my $blast = $report_dir."/blast";
			print `cp -r $s_blast_dir $blast`;
		}
		
	}

}
